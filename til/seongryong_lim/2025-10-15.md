# useReducer란 무엇인가?

아래 예시는 달력 이벤트를 업데이트하는 컴포넌트이다.

```tsx
import { useState } from "react";

function EditCalendarEvent() {
	const [startDate, setStartDate] = useState();
	const [endDate, setEndDate] = useState();
	const [title, setTitle] = useState("");
	const [description, setDescription] = useState("");
	const [location, setLocation] = useState();
	const [attendees, setAttendees] = useState([]);
	
	return (
		<>
			<input value={title} onChange={(e) => setTitle(e.target.value)} />
			{/* ... */}
		</>
	)
}
```

한눈에 읽기 어렵다는 점도 있지만 세이프가드가 없다는 문제도 있다. 종료 날짜를 시작 날짜 이전으로 선택하는 모순을 막을 방법이 없다

제목이나 설명이 너무 긴 경우에 대한 세이프가드도 존재하지 않는다.

`set*()`를 호출하는 모든 곳에서 상태를 업데이트하기 전에 이 모든 조건을 검토할 것을 기억할 것이라고, 심지어는 알고 있을 것이다.

## useState를 대체할 더 강력한 것이 있다.

`useReducer`를 사용하면 위 예시 코드를 아래와 같이 변경할 수 있다.

```tsx
import { useReducer } from "react";

function EditCalendarEvent() {
	const [event, setEvent] = useReducer(
		(prev, next) => {
			return { ...prev, ...next };
		},
		{ title: "", description: "", attendees: [] }
	);
	
	return (
		<>
			<input value={event.title} onChange={(e) => updateEvent({title: e.target.value})} />
			{/* ... */}
		</>
	)
}
```

`useReducer` 훅을 사용하면 상태 A에서 상태 B로의 변환을 제어할 수 있다.

## `useState`를 사용해서도 가능한디여??

그렇게 말씀하시면 아래와 같은 코드를 제시할 수 있습니다.

```tsx
import { useState } from "react";

function EditCalendarEvent() {
	const [event, setEvent] = useState({
		title: "",
		description: "",
		attendees: [],
	});
	
	return (
		<>
			<input
				value={event.title}
				onChange={(e) => setEvent({ ...event, title: e.target.value })}
			/>
			{/* ... */}
		</>
	);
}
```

틀린 말은 아니다. 하지만 이러한 포맷은 항상 `...event`로 전개하여 객체를 직접 변경하지 않도록 해야 한다는 것이다. 뿐만 아니라 `useReducer`의 중요한 이점인 상태 변환을 제어할 수 있는 함수를 추가할 수 있다는 점 또한 여전히 놓치고 있다.

다시 `useReducer`로 돌아가서, 유일한 차이점은 **각 상태의 변화가 안전하고 유효할 것을 보장하는 함수를 추가로 인자에 전달**한다는 점이다.

```tsx
const [event, setEvent] = useReducer(
	(prev, next) => {
		// 이벤트를 검증하고 변환하여 상태가 항상 유효할 것을 한 곳에서 관리하며 보장
		// ...
	},
	{ title: "", description: "", attendees: [] }
);
```

이는 상태를 한 곳에서 관리하며 언제나 유효하다는 것을 보장한다는 이점을 가진다.

이러한 모델을 사용하면 다른 코드들이 추가되더라도, `updateEvent()`를 유효하지 않은 데이터와 함께 호출하더라도 상태 값을 검증하는 콜백이 실행될 것이다.

예를 들어 언제 어디서 상태가 업데이트되든 절대 종료 날짜가 시작 날짜 이전일 수 없고, 제목의 길이가 최대 100자를 넘지 않도록 보장한다고 가정하자.

```tsx
import { useReducer } from "react";

function EditCalendarEvent() {
	const [event, updateEvent] = useReducer(
		(prev, next) => {
			const newEvent = { ...prev, ...next };
			if (newEvent.startDate > newEvent.endDate) {
				newEvent.endDate = newEvent.startDate;
			}
			if (newEvent.title.length > 100) {
				newEvent.title = newEvent.title.substring(0, 100);
			}
			return newEvent;
		},
		{ title: "", description: "", attendees: [] }
	);
	
	return (
		<>
			<input
				value={event.title}
				onChange={(e) => updateEvent({ title: e.target.value })}
			/>
			{/* ... */}
		</>
	);
}
```

상태를 바로 변경할 수 없도록 방지하는 이 기능은 특히 코드가 방대해질수록 중요한 안전망을 제공합니다.

UI로도 입력값이 유효한지 여부를 표시해주어야 합니다. 데이터베이스에 [ORM](https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping) 처럼 안전성을 보장하는 하나의 세트로 생각하면 상태 값이 항상 유효하다는 것을 완전히 확신할 수 있습니다. 이를 통해 향후 이상하고 디버깅하기 힘든 문제가 발생하지 않도록 방지할 수 있습니다.

## Redux스러운 것들

상황이 더욱 복잡해지면 redux 스타일의 action 기반 패턴을 사용할 수도 있다.

```tsx
import { useReducer } from "react";

function EditCalendarEvent() {
	const [event, updateEvent] = useReducer(
		(state, action) => {
			const newEvent = { ...state };
			
			switch (action.type) {
				case "updateTitle":
					newEvent.title = action.title;
					break;
				// actions
			}
			return newEvent;
		},
		{ title: "", description: "", attendees: [] }
	);
	
	return (
		<>
			<input
				value={event.title}
				onChange={(e) => updateEvent({ type: "updateTitle", title: e.target.value})}
			/>
		</>
	)
}
```

`useReducer`에 대한 문서나 글들을 보면 모두 이 방법이 useReducer 훅을 사용하는 유일한 방법처럼 설명합니다.

하지만 이 방법은 useReducer 훅을 사용할 수 있는 다양한 방법 중 하나의 방법일 뿐이라는 점을 강조하고 싶습니다. 주관적인 의견이지만, 개인적으로 Redux와 이러한 패턴을 좋아하진 않습니다.

물론 장점은 있지만 action에 대한 새로운 추상화를 레이어링하기 시작한다면 [Mobx](https://github.com/mobxjs/mobx), [Zustand](https://github.com/pmndrs/zustand), [XState](https://github.com/statelyai/xstate)와 같은 라이브러리를 추천하고 싶습니다.

그래도 추가 종속성 없이 이 패턴을 활용할 때 더 우아하기 때문에 그러한 형식을 좋아하는 사람들을 위해 제안합니다.

## Reducer 공유하기

`useReducer`의 또 다른 좋은 점은 이 훅에 의해 컨트롤되는 데이터를 자식 컴포넌트에서 업데이트하고자 할 때 편리하다는 것이다. `useState`에서는 여러 개의 함수들을 전달해야 했지만 `useReducer`에서는 reducer 함수만 전달하면 된다.

```tsx
import { createContext, useReducer } from 'react';

const TodosDispatch = createContext(null);

function TodosApp() {
	// 참고: 'dispatch' 는 리랜더 간에 변하지 않는다.
	const [todos, updateTodos] = useReducer(todosReducer);
	
	return (
		<TodosDispatch.Provider value={updateTodos}>
			<DeepTree todos={todos} />
		</TodosDispatch.Provider>
	);
}
```

자식 컴포넌트에서는 아래와 같이 사용하면 된다.

```tsx
function DeepChild(props) {
	const updateTodos = useContext(TodosDispatch);
	
	function handleClick() {
		updateTodos({ type: "add", text: "hello" });
	}
	
	return <button onClick={handleClick}>Add todo</button>;
}
```

이렇게 하면 통일된 하나의 업데이트 함수를 가질 수 있을 뿐만 아니라 자식 컴포넌트로부터 상태가 업데이트되어도 요구 사항에 부합하도록 안전성을 보장할 수 있습니다.

## 흔히 빠질 수 있는 함정

`useReducer` 훅의 상태 값은 항상 불변해야 함에 주의해야 합니다. 만약 reducer 함수에서 실수로 객체를 직접 변경시켰다면 몇 가지 문제가 발생할 수 있습니다.

```tsx
function reducer(state, action) {
	switch (action.type) {
		case "incremented_age": {
			// Wrong: 기존 객체를 변경시켰습니다
			state.age++;
			return state;
		}
		case "changed_name": {
			// Wrong: 기존 객체를 변경시켰습니다
			state.name = action.nextName;
			return state;
		}
		// ...
	}
}
```

이걸 올바르게 고치면 다음과 같다

```tsx
function reducer(state, action) {
	switch (action.type) {
		case "incremented_age": {
			return {
				...state,
				age: stage.age + 1,
			}
		}
		case "change_name": {
			return {
				...state,
				name: action.nextName,
			};
		}
		// ...
	}
}
```

## 그래서 언제 useState를 사용하고 언제 useReducer를 사용해야하는가???????

보통의 경우 `useState`를 사용해도 괜찮다.

상태와 검증 조건들이 복잡해지기 시작하며 추가적인 노력이 들어가기 시작한다고 느껴지면 그때 점진적으로 `useReducer`를 고려해도 좋다.

그 후, 복잡한 객체들에 `useReducer`를 사용하기 시작하고 상태 변경에 따른 위험에 자주 직면할 때 `Immer`의 사용을 고려해 볼 수도 있다.

혹은 상태 관리가 복잡해진 시점에 도달했다면 Mobx, Zustand, XState와 같은 훨씬 더 확장하기 쉬운 솔류션을 검토해보는 것이 좋다.